"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7725],{6079(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"interactive-playground","title":"Interactive Code Playground","description":"Interactive components for experimenting with robotics code examples","source":"@site/docs/interactive-playground.md","sourceDirName":".","slug":"/interactive-playground","permalink":"/physical-ai-humanoid-robotics-book/docs/interactive-playground","draft":false,"unlisted":false,"editUrl":"https://github.com/your-organization/physical-ai-humanoid-robotics-book/edit/main/book/docs/interactive-playground.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Interactive Code Playground","description":"Interactive components for experimenting with robotics code examples","sidebar_position":1}}');var i=t(4848),a=t(8453);const s={title:"Interactive Code Playground",description:"Interactive components for experimenting with robotics code examples",sidebar_position:1},r="Interactive Code Playground",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Interactive ROS 2 Publisher/Subscriber Example",id:"interactive-ros-2-publishersubscriber-example",level:2},{value:"Interactive Robot Navigation Simulator",id:"interactive-robot-navigation-simulator",level:2},{value:"Interactive Perception Playground",id:"interactive-perception-playground",level:2},{value:"Interactive Manipulation Simulator",id:"interactive-manipulation-simulator",level:2},{value:"How to Use These Components",id:"how-to-use-these-components",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"interactive-code-playground",children:"Interactive Code Playground"})}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"This section provides interactive code playground components that allow readers to experiment with robotics code examples directly in their browser. These components simulate the behavior of real robotic systems without requiring actual hardware or ROS 2 installation."}),"\n",(0,i.jsx)(e.h2,{id:"interactive-ros-2-publishersubscriber-example",children:"Interactive ROS 2 Publisher/Subscriber Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'import React, { useState, useEffect } from \'react\';\n\nconst ROS2Playground = () => {\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\'\');\n  const [topic, setTopic] = useState(\'/chatter\');\n  const [publisherStatus, setPublisherStatus] = useState(\'idle\');\n  const [subscriberStatus, setSubscriberStatus] = useState(\'listening\');\n\n  const publishMessage = () => {\n    if (!newMessage.trim()) return;\n\n    const message = {\n      id: Date.now(),\n      topic: topic,\n      data: newMessage,\n      timestamp: new Date().toISOString(),\n      type: \'String\'\n    };\n\n    setMessages(prev => [...prev, message]);\n    setNewMessage(\'\');\n    setPublisherStatus(\'published\');\n    \n    setTimeout(() => setPublisherStatus(\'idle\'), 1000);\n  };\n\n  const clearMessages = () => {\n    setMessages([]);\n  };\n\n  return (\n    <div className="playground-container">\n      <h3>ROS 2 Publisher/Subscriber Playground</h3>\n      \n      <div className="controls">\n        <div className="input-group">\n          <label htmlFor="topic">Topic:</label>\n          <input\n            id="topic"\n            type="text"\n            value={topic}\n            onChange={(e) => setTopic(e.target.value)}\n          />\n        </div>\n        \n        <div className="input-group">\n          <label htmlFor="message">Message:</label>\n          <input\n            id="message"\n            type="text"\n            value={newMessage}\n            onChange={(e) => setNewMessage(e.target.value)}\n            placeholder="Enter message to publish..."\n          />\n          <button onClick={publishMessage} disabled={publisherStatus === \'published\'}>\n            {publisherStatus === \'published\' ? \'Published!\' : \'Publish\'}\n          </button>\n        </div>\n        \n        <button onClick={clearMessages} className="clear-btn">Clear Messages</button>\n      </div>\n\n      <div className="status-indicators">\n        <div className={`status-indicator ${publisherStatus}`}>\n          Publisher: {publisherStatus}\n        </div>\n        <div className={`status-indicator ${subscriberStatus}`}>\n          Subscriber: {subscriberStatus}\n        </div>\n      </div>\n\n      <div className="message-log">\n        <h4>Message Log</h4>\n        {messages.length === 0 ? (\n          <p className="no-messages">No messages yet. Publish a message to see it here.</p>\n        ) : (\n          <ul>\n            {messages.map((msg) => (\n              <li key={msg.id} className="message-item">\n                <div className="message-header">\n                  <span className="topic">{msg.topic}</span>\n                  <span className="timestamp">{msg.timestamp}</span>\n                </div>\n                <div className="message-content">\n                  {msg.data}\n                </div>\n              </li>\n            ))}\n          </ul>\n        )}\n      </div>\n\n      <div className="explanation">\n        <h4>How It Works</h4>\n        <p>\n          This interactive playground simulates the basic functionality of ROS 2 publishers and subscribers:\n        </p>\n        <ul>\n          <li><strong>Publisher</strong>: Sends messages to a specified topic</li>\n          <li><strong>Subscriber</strong>: Receives messages from topics it\'s listening to</li>\n          <li><strong>Topic</strong>: Named channel for message exchange</li>\n          <li><strong>Messages</strong>: Data sent between nodes in a standardized format</li>\n        </ul>\n        <p>\n          In a real ROS 2 system, publishers and subscribers would be in separate nodes running on the same or different machines.\n          The ROS 2 middleware (DDS) handles the communication between them based on topic names.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default ROS2Playground;\n'})}),"\n",(0,i.jsx)(e.h2,{id:"interactive-robot-navigation-simulator",children:"Interactive Robot Navigation Simulator"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:"import React, { useState, useEffect, useRef } from 'react';\n\nconst NavigationSimulator = () => {\n  const canvasRef = useRef(null);\n  const [robotPos, setRobotPos] = useState({ x: 50, y: 50 });\n  const [goalPos, setGoalPos] = useState({ x: 400, y: 300 });\n  const [obstacles, setObstacles] = useState([\n    { x: 150, y: 150, width: 50, height: 50 },\n    { x: 250, y: 200, width: 30, height: 80 },\n    { x: 350, y: 100, width: 70, height: 30 }\n  ]);\n  const [isNavigating, setIsNavigating] = useState(false);\n  const [path, setPath] = useState([]);\n\n  // Draw the environment\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw obstacles\n    ctx.fillStyle = '#8B4513';\n    obstacles.forEach(obstacle => {\n      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);\n    });\n    \n    // Draw goal\n    ctx.fillStyle = '#00FF00';\n    ctx.beginPath();\n    ctx.arc(goalPos.x, goalPos.y, 10, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw path if exists\n    if (path.length > 1) {\n      ctx.strokeStyle = '#0000FF';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(path[0].x, path[0].y);\n      for (let i = 1; i < path.length; i++) {\n        ctx.lineTo(path[i].x, path[i].y);\n      }\n      ctx.stroke();\n    }\n    \n    // Draw robot\n    ctx.fillStyle = '#FF0000';\n    ctx.beginPath();\n    ctx.arc(robotPos.x, robotPos.y, 8, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw robot direction indicator\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(robotPos.x, robotPos.y);\n    ctx.lineTo(robotPos.x + 15, robotPos.y);\n    ctx.stroke();\n  }, [robotPos, goalPos, obstacles, path]);\n\n  // Simple path planning (straight line with obstacle avoidance)\n  const planPath = () => {\n    // In a real system, this would use A* or D* algorithm\n    // For this simulation, we'll create a simple path\n    const newPath = [];\n    let currentX = robotPos.x;\n    let currentY = robotPos.y;\n    \n    // Move in steps toward the goal\n    const steps = 50;\n    for (let i = 0; i <= steps; i++) {\n      const t = i / steps;\n      const x = robotPos.x + (goalPos.x - robotPos.x) * t;\n      const y = robotPos.y + (goalPos.y - robotPos.y) * t;\n      newPath.push({ x, y });\n    }\n    \n    // Add simple obstacle avoidance\n    const adjustedPath = newPath.map(point => {\n      // Check if point is too close to any obstacle\n      for (const obs of obstacles) {\n        const distX = Math.abs(point.x - (obs.x + obs.width/2));\n        const distY = Math.abs(point.y - (obs.y + obs.height/2));\n        const halfWidth = obs.width/2 + 15;\n        const halfHeight = obs.height/2 + 15;\n        \n        if (distX <= halfWidth && distY <= halfHeight) {\n          // Move point away from obstacle\n          return {\n            x: point.x + (point.x < obs.x ? -20 : 20),\n            y: point.y + (point.y < obs.y ? -20 : 20)\n          };\n        }\n      }\n      return point;\n    });\n    \n    setPath(adjustedPath);\n    return adjustedPath;\n  };\n\n  const startNavigation = () => {\n    if (isNavigating) return;\n    \n    const plannedPath = planPath();\n    setIsNavigating(true);\n    \n    // Animate the robot along the path\n    let step = 0;\n    const interval = setInterval(() => {\n      if (step < plannedPath.length) {\n        setRobotPos(plannedPath[step]);\n        step++;\n      } else {\n        clearInterval(interval);\n        setIsNavigating(false);\n      }\n    }, 100); // Move every 100ms\n  };\n\n  const resetSimulation = () => {\n    setRobotPos({ x: 50, y: 50 });\n    setPath([]);\n    setIsNavigating(false);\n  };\n\n  const handleCanvasClick = (e) => {\n    if (isNavigating) return;\n    \n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Check if click is on an obstacle\n    let onObstacle = false;\n    for (const obs of obstacles) {\n      if (x >= obs.x && x <= obs.x + obs.width && \n          y >= obs.y && y <= obs.y + obs.height) {\n        onObstacle = true;\n        break;\n      }\n    }\n    \n    if (!onObstacle) {\n      setGoalPos({ x, y });\n    }\n  };\n\n  return (\n    <div className=\"navigation-simulator\">\n      <h3>Robot Navigation Simulator</h3>\n      \n      <div className=\"simulator-controls\">\n        <button onClick={startNavigation} disabled={isNavigating}>\n          {isNavigating ? 'Navigating...' : 'Start Navigation'}\n        </button>\n        <button onClick={resetSimulation}>Reset</button>\n        <p>Click on the map to set a new goal (avoid obstacles)</p>\n      </div>\n      \n      <div className=\"canvas-container\">\n        <canvas\n          ref={canvasRef}\n          width={500}\n          height={400}\n          onClick={handleCanvasClick}\n          style={% raw %}{{ border: '1px solid #ccc', background: '#f0f0f0' }}{% endraw %}\n        />\n      </div>\n      \n      <div className=\"simulator-info\">\n        <h4>Navigation Concepts Demonstrated</h4>\n        <ul>\n          <li><strong>Path Planning</strong>: Finding a route from start to goal</li>\n          <li><strong>Obstacle Avoidance</strong>: Navigating around obstacles</li>\n          <li><strong>Localization</strong>: Knowing the robot's position</li>\n          <li><strong>Motion Control</strong>: Moving the robot along the path</li>\n        </ul>\n        \n        <p>\n          In a real robotic system, navigation involves more sophisticated algorithms like A*, D*, or RRT for path planning,\n          and Dynamic Window Approach (DWA) or Trajectory Rollout for local obstacle avoidance.\n          This simulation demonstrates the basic concepts without the complexity of real-world implementation.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default NavigationSimulator;\n"})}),"\n",(0,i.jsx)(e.h2,{id:"interactive-perception-playground",children:"Interactive Perception Playground"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:"import React, { useState, useRef, useEffect } from 'react';\n\nconst PerceptionPlayground = () => {\n  const canvasRef = useRef(null);\n  const [detectedObjects, setDetectedObjects] = useState([]);\n  const [selectedTool, setSelectedTool] = useState('add');\n  const [detectionMode, setDetectionMode] = useState('color');\n  const [isDetecting, setIsDetecting] = useState(false);\n\n  // Draw the scene\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw background\n    ctx.fillStyle = '#e0e0e0';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw objects\n    detectedObjects.forEach(obj => {\n      ctx.fillStyle = obj.color;\n      ctx.beginPath();\n      if (obj.shape === 'rectangle') {\n        ctx.rect(obj.x, obj.y, obj.width, obj.height);\n      } else if (obj.shape === 'circle') {\n        ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);\n      } else if (obj.shape === 'triangle') {\n        ctx.moveTo(obj.x, obj.y);\n        ctx.lineTo(obj.x + obj.width, obj.y);\n        ctx.lineTo(obj.x + obj.width/2, obj.y - obj.height);\n        ctx.closePath();\n      }\n      ctx.fill();\n      \n      // Draw object label\n      ctx.fillStyle = '#000';\n      ctx.font = '12px Arial';\n      ctx.fillText(obj.label, obj.x, obj.y - 10);\n    });\n  }, [detectedObjects]);\n\n  const handleCanvasClick = (e) => {\n    if (selectedTool !== 'add' || isDetecting) return;\n    \n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Add a new object\n    const newObject = {\n      id: Date.now(),\n      x,\n      y,\n      width: 40 + Math.random() * 40,\n      height: 40 + Math.random() * 40,\n      radius: 20 + Math.random() * 30,\n      shape: ['rectangle', 'circle', 'triangle'][Math.floor(Math.random() * 3)],\n      color: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF'][Math.floor(Math.random() * 5)],\n      label: `Object ${detectedObjects.length + 1}`\n    };\n    \n    setDetectedObjects(prev => [...prev, newObject]);\n  };\n\n  const detectObjects = () => {\n    if (isDetecting) return;\n    \n    setIsDetecting(true);\n    \n    // Simulate detection process\n    setTimeout(() => {\n      // In a real system, this would use computer vision algorithms\n      // For this simulation, we'll just return the existing objects\n      setIsDetecting(false);\n    }, 1500);\n  };\n\n  const clearScene = () => {\n    setDetectedObjects([]);\n  };\n\n  return (\n    <div className=\"perception-playground\">\n      <h3>Perception Playground</h3>\n      \n      <div className=\"playground-controls\">\n        <div className=\"tool-selector\">\n          <label>\n            <input\n              type=\"radio\"\n              name=\"tool\"\n              value=\"add\"\n              checked={selectedTool === 'add'}\n              onChange={() => setSelectedTool('add')}\n            />\n            Add Objects\n          </label>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"tool\"\n              value=\"detect\"\n              checked={selectedTool === 'detect'}\n              onChange={() => setSelectedTool('detect')}\n            />\n            Detect Objects\n          </label>\n        </div>\n        \n        <div className=\"detection-mode\">\n          <label>\n            Detection Mode:\n            <select \n              value={detectionMode} \n              onChange={(e) => setDetectionMode(e.target.value)}\n            >\n              <option value=\"color\">Color-based Detection</option>\n              <option value=\"shape\">Shape-based Detection</option>\n              <option value=\"size\">Size-based Detection</option>\n            </select>\n          </label>\n        </div>\n        \n        <div className=\"action-buttons\">\n          <button onClick={detectObjects} disabled={isDetecting || selectedTool !== 'detect'}>\n            {isDetecting ? 'Detecting...' : 'Run Detection'}\n          </button>\n          <button onClick={clearScene}>Clear Scene</button>\n        </div>\n      </div>\n      \n      <div className=\"canvas-container\">\n        <canvas\n          ref={canvasRef}\n          width={600}\n          height={400}\n          onClick={handleCanvasClick}\n          style={% raw %}{{ border: '1px solid #ccc', background: '#f0f0f0' }}{% endraw %}\n        />\n      </div>\n      \n      <div className=\"detection-results\">\n        <h4>Detection Results</h4>\n        {detectedObjects.length === 0 ? (\n          <p>No objects detected. Add objects or run detection.</p>\n        ) : (\n          <div className=\"object-grid\">\n            {detectedObjects.map(obj => (\n              <div key={obj.id} className=\"object-card\">\n                <div\n                  className=\"object-preview\"\n                  style={% raw %}{{\n                    backgroundColor: obj.color,\n                    width: '50px',\n                    height: '50px',\n                    display: 'inline-block',\n                    marginRight: '10px'\n                  }}{% endraw %}\n                />\n                <div>\n                  <strong>{obj.label}</strong><br/>\n                  Shape: {obj.shape}<br/>\n                  Position: ({Math.round(obj.x)}, {Math.round(obj.y)})\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"explanation\">\n        <h4>Perception Concepts Demonstrated</h4>\n        <ul>\n          <li><strong>Object Detection</strong>: Identifying objects in the environment</li>\n          <li><strong>Feature Extraction</strong>: Identifying object characteristics (color, shape, size)</li>\n          <li><strong>Scene Understanding</strong>: Interpreting the spatial relationships between objects</li>\n          <li><strong>Computer Vision</strong>: Algorithms for image processing and analysis</li>\n        </ul>\n        \n        <p>\n          In real robotic systems, perception involves sophisticated algorithms like convolutional neural networks (CNNs) \n          for object detection, SLAM for mapping and localization, and sensor fusion to combine data from multiple sources \n          (cameras, LIDAR, IMU, etc.).\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default PerceptionPlayground;\n"})}),"\n",(0,i.jsx)(e.h2,{id:"interactive-manipulation-simulator",children:"Interactive Manipulation Simulator"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:"import React, { useState, useRef, useEffect } from 'react';\n\nconst ManipulationSimulator = () => {\n  const canvasRef = useRef(null);\n  const [armJoints, setArmJoints] = useState([\n    { angle: 0, length: 80 },  // Shoulder\n    { angle: 0, length: 70 },  // Elbow\n    { angle: 0, length: 60 }   // Wrist\n  ]);\n  const [gripperOpen, setGripperOpen] = useState(true);\n  const [heldObject, setHeldObject] = useState(null);\n  const [objects, setObjects] = useState([\n    { id: 1, x: 300, y: 300, width: 30, height: 30, color: '#FF0000', label: 'Red Block' },\n    { id: 2, x: 350, y: 250, width: 25, height: 40, color: '#00FF00', label: 'Green Cylinder' },\n    { id: 3, x: 250, y: 320, width: 35, height: 25, color: '#0000FF', label: 'Blue Box' }\n  ]);\n  const [targetPosition, setTargetPosition] = useState({ x: 400, y: 100 });\n\n  // Draw the robotic arm and environment\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw base\n    ctx.fillStyle = '#808080';\n    ctx.fillRect(50 - 20, canvas.height - 20, 40, 20);\n    \n    // Calculate arm positions\n    let currentX = 50;\n    let currentY = canvas.height - 20;\n    let currentAngle = 0;\n    \n    // Draw arm links\n    armJoints.forEach((joint, index) => {\n      const newX = currentX + Math.cos(currentAngle + joint.angle) * joint.length;\n      const newY = currentY - Math.sin(currentAngle + joint.angle) * joint.length;\n      \n      // Draw link\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 8;\n      ctx.beginPath();\n      ctx.moveTo(currentX, currentY);\n      ctx.lineTo(newX, newY);\n      ctx.stroke();\n      \n      // Draw joint\n      ctx.fillStyle = '#666';\n      ctx.beginPath();\n      ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);\n      ctx.fill();\n      \n      currentX = newX;\n      currentY = newY;\n      currentAngle += joint.angle;\n    });\n    \n    // Draw gripper\n    const gripperSize = gripperOpen ? 15 : 5;\n    ctx.fillStyle = '#333';\n    ctx.fillRect(currentX - 10, currentY - gripperSize/2, 10, gripperSize);\n    \n    // Draw gripper fingers\n    ctx.fillStyle = '#555';\n    ctx.fillRect(currentX, currentY - gripperSize/2 - 5, 5, gripperSize + 10);\n    ctx.fillRect(currentX, currentY - gripperSize/2 - 5 + (gripperOpen ? 15 : 5), 5, gripperSize + 10);\n    \n    // Draw held object if any\n    if (heldObject) {\n      const obj = objects.find(o => o.id === heldObject.id);\n      if (obj) {\n        ctx.fillStyle = obj.color;\n        ctx.fillRect(\n          currentX - obj.width/2, \n          currentY - obj.height/2, \n          obj.width, \n          obj.height\n        );\n      }\n    }\n    \n    // Draw objects in the environment\n    objects.forEach(obj => {\n      if (obj.id !== heldObject?.id) { // Don't draw if held\n        ctx.fillStyle = obj.color;\n        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);\n        \n        // Draw object label\n        ctx.fillStyle = '#000';\n        ctx.font = '12px Arial';\n        ctx.fillText(obj.label, obj.x, obj.y - 5);\n      }\n    });\n    \n    // Draw target position\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';\n    ctx.beginPath();\n    ctx.arc(targetPosition.x, targetPosition.y, 15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#00FF00';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n  }, [armJoints, gripperOpen, objects, heldObject, targetPosition]);\n\n  const moveJoint = (index, delta) => {\n    setArmJoints(prev => {\n      const newJoints = [...prev];\n      newJoints[index].angle += delta;\n      return newJoints;\n    });\n  };\n\n  const toggleGripper = () => {\n    if (heldObject) {\n      // Release object\n      setHeldObject(null);\n    } else {\n      // Check if we're close to an object to grasp\n      const canvas = canvasRef.current;\n      let currentX = 50;\n      let currentY = canvas.height - 20;\n      let currentAngle = 0;\n      \n      // Calculate end effector position\n      armJoints.forEach(joint => {\n        currentX = currentX + Math.cos(currentAngle + joint.angle) * joint.length;\n        currentY = currentY - Math.sin(currentAngle + joint.angle) * joint.length;\n        currentAngle += joint.angle;\n      });\n      \n      // Check distance to objects\n      for (const obj of objects) {\n        const dx = currentX - (obj.x + obj.width/2);\n        const dy = currentY - (obj.y + obj.height/2);\n        const distance = Math.sqrt(dx*dx + dy*dy);\n        \n        if (distance < 30) { // Within grasp range\n          setHeldObject(obj);\n          break;\n        }\n      }\n    }\n    \n    setGripperOpen(!gripperOpen);\n  };\n\n  const goToTarget = () => {\n    // This would use inverse kinematics in a real system\n    // For this simulation, we'll just move joints to approximate the target\n    const targetX = targetPosition.x;\n    const targetY = targetPosition.y;\n    \n    // Calculate angles to reach target (simplified)\n    const dx = targetX - 50;\n    const dy = (canvasRef.current.height - 20) - targetY;\n    const distance = Math.sqrt(dx*dx + dy*dy);\n    \n    // Simple approximation - in reality this would use inverse kinematics\n    const angle1 = Math.atan2(dy, dx);\n    const angle2 = 0; // Simplified\n    const angle3 = 0; // Simplified\n    \n    setArmJoints([\n      { angle: angle1, length: 80 },\n      { angle: angle2, length: 70 },\n      { angle: angle3, length: 60 }\n    ]);\n  };\n\n  const updateTarget = (e) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    setTargetPosition({ x, y });\n  };\n\n  return (\n    <div className=\"manipulation-simulator\">\n      <h3>Robotic Manipulation Simulator</h3>\n      \n      <div className=\"simulator-controls\">\n        <div className=\"joint-controls\">\n          <h4>Joint Controls</h4>\n          {armJoints.map((joint, index) => (\n            <div key={index} className=\"joint-control\">\n              <label>Joint {index + 1}:</label>\n              <button onClick={() => moveJoint(index, -0.1)}>\u2190</button>\n              <button onClick={() => moveJoint(index, 0.1)}>\u2192</button>\n              <span>Angle: {(joint.angle * 180 / Math.PI).toFixed(1)}\xb0</span>\n            </div>\n          ))}\n        </div>\n        \n        <div className=\"gripper-control\">\n          <h4>Gripper Control</h4>\n          <button onClick={toggleGripper}>\n            {gripperOpen ? 'Close Gripper' : 'Open Gripper'}\n          </button>\n          <p>Status: {gripperOpen ? 'Open' : 'Closed'}</p>\n          {heldObject && <p>Holding: {heldObject.label}</p>}\n        </div>\n        \n        <div className=\"action-controls\">\n          <h4>Actions</h4>\n          <button onClick={goToTarget}>Go to Target</button>\n          <button onClick={() => setTargetPosition({ x: 400, y: 100 })}>Reset Target</button>\n        </div>\n      </div>\n      \n      <div className=\"canvas-container\">\n        <canvas\n          ref={canvasRef}\n          width={600}\n          height={400}\n          onClick={updateTarget}\n          style={% raw %}{{ border: '1px solid #ccc', background: '#f9f9f9' }}{% endraw %}\n        />\n        <p>Click on the canvas to set a new target position</p>\n      </div>\n      \n      <div className=\"explanation\">\n        <h4>Manipulation Concepts Demonstrated</h4>\n        <ul>\n          <li><strong>Forward Kinematics</strong>: Calculating end-effector position from joint angles</li>\n          <li><strong>Inverse Kinematics</strong>: Calculating joint angles to reach a target position</li>\n          <li><strong>Grasping</strong>: Controlling the gripper to pick up objects</li>\n          <li><strong>Manipulation Planning</strong>: Planning trajectories to avoid collisions</li>\n        </ul>\n        \n        <p>\n          In real robotic manipulation systems, precise control algorithms, force feedback, \n          and advanced grasp planning are used to reliably manipulate objects. \n          This simulation demonstrates the basic concepts of robotic arm control and manipulation.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default ManipulationSimulator;\n"})}),"\n",(0,i.jsx)(e.h2,{id:"how-to-use-these-components",children:"How to Use These Components"}),"\n",(0,i.jsx)(e.p,{children:"To use these interactive components in your Docusaurus site, you would:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Create a new React component file in your ",(0,i.jsx)(e.code,{children:"src/components"})," directory"]}),"\n",(0,i.jsx)(e.li,{children:"Add the code for the component you want to use"}),"\n",(0,i.jsx)(e.li,{children:"Import and use the component in your markdown files:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-markdown",children:"import ROS2Playground from '@site/src/components/ROS2Playground';\nimport NavigationSimulator from '@site/src/components/NavigationSimulator';\nimport PerceptionPlayground from '@site/src/components/PerceptionPlayground';\nimport ManipulationSimulator from '@site/src/components/ManipulationSimulator';\n\n# Interactive Robotics Playground\n\n<ROS2Playground />\n\n<NavigationSimulator />\n\n<PerceptionPlayground />\n\n<ManipulationSimulator />\n"})}),"\n",(0,i.jsx)(e.p,{children:"These interactive components provide hands-on experience with robotics concepts without requiring actual hardware or ROS 2 installation, making them ideal for educational purposes in the context of this book."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);