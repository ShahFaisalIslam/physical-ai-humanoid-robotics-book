"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[8319],{4904(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-ros-fundamentals/urdf-for-humanoids","title":"URDF for Humanoids","description":"URDF (Unified Robot Description Format) is an XML format used in ROS to describe robot models. For humanoid robots, URDF is essential for defining the physical structure, kinematic properties, and visual representation of the robot.","source":"@site/docs/module-1-ros-fundamentals/urdf-for-humanoids.md","sourceDirName":"module-1-ros-fundamentals","slug":"/module-1-ros-fundamentals/urdf-for-humanoids","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1-ros-fundamentals/urdf-for-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/your-organization/physical-ai-humanoid-robotics-book/edit/main/book/docs/module-1-ros-fundamentals/urdf-for-humanoids.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"rclpy Basics","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1-ros-fundamentals/rclpy-basics"},"next":{"title":"Gazebo Simulation","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/gazebo-simulation"}}');var r=i(4848),l=i(8453);const s={sidebar_position:4},t="URDF for Humanoids",a={},c=[{value:"What is URDF?",id:"what-is-urdf",level:2},{value:"Basic URDF Structure",id:"basic-urdf-structure",level:2},{value:"Links",id:"links",level:2},{value:"Visual Elements",id:"visual-elements",level:3},{value:"Collision Elements",id:"collision-elements",level:3},{value:"Inertial Elements",id:"inertial-elements",level:3},{value:"Joints",id:"joints",level:2},{value:"Revolute Joints",id:"revolute-joints",level:3},{value:"Fixed Joints",id:"fixed-joints",level:3},{value:"Continuous Joints",id:"continuous-joints",level:3},{value:"Humanoid Robot Structure",id:"humanoid-robot-structure",level:2},{value:"URDF for a Simple Humanoid",id:"urdf-for-a-simple-humanoid",level:2},{value:"Xacro for Complex Models",id:"xacro-for-complex-models",level:2},{value:"Best Practices for Humanoid URDFs",id:"best-practices-for-humanoid-urdfs",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"urdf-for-humanoids",children:"URDF for Humanoids"})}),"\n",(0,r.jsx)(e.p,{children:"URDF (Unified Robot Description Format) is an XML format used in ROS to describe robot models. For humanoid robots, URDF is essential for defining the physical structure, kinematic properties, and visual representation of the robot."}),"\n",(0,r.jsx)(e.h2,{id:"what-is-urdf",children:"What is URDF?"}),"\n",(0,r.jsx)(e.p,{children:"URDF is an XML format that describes robot models, including:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Physical structure (links and joints)"}),"\n",(0,r.jsx)(e.li,{children:"Kinematic properties (mass, inertia, limits)"}),"\n",(0,r.jsx)(e.li,{children:"Visual representation (meshes, colors)"}),"\n",(0,r.jsx)(e.li,{children:"Collision properties"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"basic-urdf-structure",children:"Basic URDF Structure"}),"\n",(0,r.jsxs)(e.p,{children:["A URDF file has a root ",(0,r.jsx)(e.code,{children:"<robot>"})," element containing ",(0,r.jsx)(e.code,{children:"<link>"})," and ",(0,r.jsx)(e.code,{children:"<joint>"})," elements:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_robot">\n  \x3c!-- Links define rigid bodies --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.5 0.5"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.5 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Joints connect links --\x3e\n  <joint name="joint_name" type="revolute">\n    <parent link="base_link"/>\n    <child link="child_link"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  </joint>\n  \n  <link name="child_link">\n    \x3c!-- Child link definition --\x3e\n  </link>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"links",children:"Links"}),"\n",(0,r.jsx)(e.p,{children:"Links represent rigid bodies in the robot. Each link can have:"}),"\n",(0,r.jsx)(e.h3,{id:"visual-elements",children:"Visual Elements"}),"\n",(0,r.jsx)(e.p,{children:"Define how the link appears in visualizations:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n    \x3c!-- or <cylinder radius="0.1" length="0.2"/> --\x3e\n    \x3c!-- or <sphere radius="0.1"/> --\x3e\n    \x3c!-- or <mesh filename="package://path/to/mesh.stl"/> --\x3e\n  </geometry>\n  <material name="blue">\n    <color rgba="0 0 1 1"/>\n  </material>\n</visual>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"collision-elements",children:"Collision Elements"}),"\n",(0,r.jsx)(e.p,{children:"Define collision properties:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"inertial-elements",children:"Inertial Elements"}),"\n",(0,r.jsx)(e.p,{children:"Define physical properties:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<inertial>\n  <mass value="0.1"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n</inertial>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"joints",children:"Joints"}),"\n",(0,r.jsx)(e.p,{children:"Joints connect links and define their motion. Common joint types:"}),"\n",(0,r.jsx)(e.h3,{id:"revolute-joints",children:"Revolute Joints"}),"\n",(0,r.jsx)(e.p,{children:"Rotate around a single axis (like a hinge):"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<joint name="elbow_joint" type="revolute">\n  <parent link="upper_arm"/>\n  <child link="forearm"/>\n  <origin xyz="0 0 0.3" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-2.0" upper="1.5" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"fixed-joints",children:"Fixed Joints"}),"\n",(0,r.jsx)(e.p,{children:"Rigid connection with no movement:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<joint name="fixed_joint" type="fixed">\n  <parent link="base"/>\n  <child link="sensor_mount"/>\n  <origin xyz="0.1 0 0.2" rpy="0 0 0"/>\n</joint>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"continuous-joints",children:"Continuous Joints"}),"\n",(0,r.jsx)(e.p,{children:"Rotate continuously around an axis:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<joint name="continuous_joint" type="continuous">\n  <parent link="torso"/>\n  <child link="head"/>\n  <axis xyz="0 0 1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"humanoid-robot-structure",children:"Humanoid Robot Structure"}),"\n",(0,r.jsx)(e.p,{children:"A humanoid robot typically has a hierarchical structure:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"root (base_link)\n\u251c\u2500\u2500 pelvis\n    \u251c\u2500\u2500 left_leg\n    \u2502   \u251c\u2500\u2500 left_lower_leg\n    \u2502   \u2514\u2500\u2500 left_foot\n    \u251c\u2500\u2500 right_leg\n    \u2502   \u251c\u2500\u2500 right_lower_leg\n    \u2502   \u2514\u2500\u2500 right_foot\n    \u251c\u2500\u2500 torso\n        \u251c\u2500\u2500 neck\n        \u2502   \u2514\u2500\u2500 head\n        \u251c\u2500\u2500 left_arm\n        \u2502   \u251c\u2500\u2500 left_lower_arm\n        \u2502   \u2514\u2500\u2500 left_hand\n        \u2514\u2500\u2500 right_arm\n            \u251c\u2500\u2500 right_lower_arm\n            \u2514\u2500\u2500 right_hand\n"})}),"\n",(0,r.jsx)(e.h2,{id:"urdf-for-a-simple-humanoid",children:"URDF for a Simple Humanoid"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example URDF for a simplified humanoid:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Pelvis (root link) --\x3e\n  <link name="pelvis">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.1"/>\n      </geometry>\n      <material name="grey">\n        <color rgba="0.5 0.5 0.5 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <joint name="torso_joint" type="revolute">\n    <parent link="pelvis"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="100" velocity="1"/>\n  </joint>\n\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.2 0.3 0.4"/>\n      </geometry>\n      <material name="light_grey">\n        <color rgba="0.7 0.7 0.7 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.3 0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="8.0"/>\n      <inertia ixx="0.2" ixy="0" ixz="0" iyy="0.2" iyz="0" izz="0.2"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.4" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10" velocity="1"/>\n  </joint>\n\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="1 0.8 0.6 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Arm --\x3e\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="-0.15 0 0.2" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="left_upper_arm">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n      <material name="arm_color">\n        <color rgba="0.2 0.6 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Additional joints and links would continue in this pattern --\x3e\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"xacro-for-complex-models",children:"Xacro for Complex Models"}),"\n",(0,r.jsx)(e.p,{children:"For complex humanoid robots, Xacro (XML Macros) is often used to make URDF files more manageable:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_with_xacro">\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  \n  \x3c!-- Define a macro for a simple arm --\x3e\n  <xacro:macro name="simple_arm" params="prefix parent_link x y z roll pitch yaw">\n    <joint name="${prefix}_shoulder_joint" type="revolute">\n      <parent link="${parent_link}"/>\n      <child link="${prefix}_upper_arm"/>\n      <origin xyz="${x} ${y} ${z}" rpy="${roll} ${pitch} ${yaw}"/>\n      <axis xyz="0 0 1"/>\n      <limit lower="-1.57" upper="1.57" effort="50" velocity="1"/>\n    </joint>\n\n    <link name="${prefix}_upper_arm">\n      <visual>\n        <geometry>\n          <cylinder radius="0.05" length="0.3"/>\n        </geometry>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder radius="0.05" length="0.3"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="1.0"/>\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Use the macro to create both arms --\x3e\n  <xacro:simple_arm prefix="left" parent_link="torso" x="-0.15" y="0" z="0.2" roll="0" pitch="0" yaw="0"/>\n  <xacro:simple_arm prefix="right" parent_link="torso" x="0.15" y="0" z="0.2" roll="0" pitch="0" yaw="0"/>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices-for-humanoid-urdfs",children:"Best Practices for Humanoid URDFs"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use appropriate units"}),": All distances in meters, angles in radians"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Set realistic inertial properties"}),": Mass and inertia affect simulation accuracy"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Consider joint limits"}),": Set realistic limits based on human anatomy"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use visual and collision elements"}),": Separate for better performance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Validate your URDF"}),": Use tools like ",(0,r.jsx)(e.code,{children:"check_urdf"})," to verify syntax"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Organize complex models"}),": Use Xacro to avoid repetition"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"URDF is fundamental to humanoid robotics in ROS 2, providing the necessary description for simulation, visualization, and control algorithms."})]})}function m(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>s,x:()=>t});var o=i(6540);const r={},l=o.createContext(r);function s(n){const e=o.useContext(l);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(l.Provider,{value:e},n.children)}}}]);