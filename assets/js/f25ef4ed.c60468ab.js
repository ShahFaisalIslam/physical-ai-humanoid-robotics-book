"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[8944],{574(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"module-3-ai-robot-brain/nav2-path-planning","title":"Path Planning for Bipedal Humanoid Movement","description":"Path planning for bipedal humanoid robots presents unique challenges compared to wheeled or simpler mobile robots. Humanoid robots must navigate with dynamic balance, consider their complex kinematics, and plan paths that account for their distinctive locomotion patterns. NVIDIA Isaac provides specialized tools for this complex path planning task.","source":"@site/docs/module-3-ai-robot-brain/nav2-path-planning.md","sourceDirName":"module-3-ai-robot-brain","slug":"/module-3-ai-robot-brain/nav2-path-planning","permalink":"/physical-ai-humanoid-robotics-book/docs/module-3-ai-robot-brain/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/your-organization/physical-ai-humanoid-robotics-book/edit/main/book/docs/module-3-ai-robot-brain/nav2-path-planning.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Visual SLAM and Navigation in NVIDIA Isaac","permalink":"/physical-ai-humanoid-robotics-book/docs/module-3-ai-robot-brain/vslam-navigation"},"next":{"title":"Whisper Integration for Speech Recognition","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4-vision-language-action/whisper-integration"}}');var i=t(4848),o=t(8453);const r={sidebar_position:4},s="Path Planning for Bipedal Humanoid Movement",l={},p=[{value:"Challenges of Humanoid Path Planning",id:"challenges-of-humanoid-path-planning",level:2},{value:"Dynamic Balance Considerations",id:"dynamic-balance-considerations",level:3},{value:"Kinematic Constraints",id:"kinematic-constraints",level:3},{value:"Terrain Adaptability",id:"terrain-adaptability",level:3},{value:"Isaac Path Planning Architecture for Humanoids",id:"isaac-path-planning-architecture-for-humanoids",level:2},{value:"Isaac Navigation 2 for Humanoids",id:"isaac-navigation-2-for-humanoids",level:3},{value:"Humanoid-Specific Path Planning Algorithms",id:"humanoid-specific-path-planning-algorithms",level:2},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Whole-Body Path Planning",id:"whole-body-path-planning",level:3},{value:"GPU-Accelerated Path Planning",id:"gpu-accelerated-path-planning",level:2},{value:"Isaac&#39;s GPU-Accelerated Algorithms",id:"isaacs-gpu-accelerated-algorithms",level:3},{value:"Balance-Aware Path Planning",id:"balance-aware-path-planning",level:2},{value:"Center of Mass Constraints",id:"center-of-mass-constraints",level:3},{value:"Terrain-Aware Path Planning",id:"terrain-aware-path-planning",level:2},{value:"Handling Different Terrains",id:"handling-different-terrains",level:3},{value:"Integration with Isaac Sim",id:"integration-with-isaac-sim",level:2},{value:"Testing in Simulation",id:"testing-in-simulation",level:3},{value:"Best Practices for Humanoid Path Planning",id:"best-practices-for-humanoid-path-planning",level:2},{value:"1. Multi-Layer Planning",id:"1-multi-layer-planning",level:3},{value:"2. Balance Integration",id:"2-balance-integration",level:3},{value:"3. Terrain Adaptation",id:"3-terrain-adaptation",level:3},{value:"4. Performance Optimization",id:"4-performance-optimization",level:3},{value:"5. Validation and Testing",id:"5-validation-and-testing",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"path-planning-for-bipedal-humanoid-movement",children:"Path Planning for Bipedal Humanoid Movement"})}),"\n",(0,i.jsx)(e.p,{children:"Path planning for bipedal humanoid robots presents unique challenges compared to wheeled or simpler mobile robots. Humanoid robots must navigate with dynamic balance, consider their complex kinematics, and plan paths that account for their distinctive locomotion patterns. NVIDIA Isaac provides specialized tools for this complex path planning task."}),"\n",(0,i.jsx)(e.h2,{id:"challenges-of-humanoid-path-planning",children:"Challenges of Humanoid Path Planning"}),"\n",(0,i.jsx)(e.h3,{id:"dynamic-balance-considerations",children:"Dynamic Balance Considerations"}),"\n",(0,i.jsx)(e.p,{children:"Unlike wheeled robots, bipedal robots must maintain balance during movement:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Center of Mass (CoM) must remain within support polygon"}),"\n",(0,i.jsx)(e.li,{children:"Zero Moment Point (ZMP) constraints must be satisfied"}),"\n",(0,i.jsx)(e.li,{children:"Gait patterns must be stable and energy-efficient"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"kinematic-constraints",children:"Kinematic Constraints"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots have complex kinematic chains:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Multiple degrees of freedom in legs"}),"\n",(0,i.jsx)(e.li,{children:"Joint limits and collision avoidance"}),"\n",(0,i.jsx)(e.li,{children:"Foot placement constraints"}),"\n",(0,i.jsx)(e.li,{children:"Upper body stability requirements"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"terrain-adaptability",children:"Terrain Adaptability"}),"\n",(0,i.jsx)(e.p,{children:"Humanoids need to handle various terrains:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Uneven surfaces"}),"\n",(0,i.jsx)(e.li,{children:"Stairs and steps"}),"\n",(0,i.jsx)(e.li,{children:"Narrow passages"}),"\n",(0,i.jsx)(e.li,{children:"Obstacles at different heights"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"isaac-path-planning-architecture-for-humanoids",children:"Isaac Path Planning Architecture for Humanoids"}),"\n",(0,i.jsx)(e.h3,{id:"isaac-navigation-2-for-humanoids",children:"Isaac Navigation 2 for Humanoids"}),"\n",(0,i.jsx)(e.p,{children:"The Isaac Navigation 2 stack can be configured specifically for humanoid robots:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Humanoid-specific Navigation 2 configuration\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /visual_slam/odometry\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Behavior tree for humanoid navigation\n    bt_xml_filename: "humanoid_navigate_w_replanning_and_recovery.xml"\n    recovery_plugins: ["humanoid_spin", "backup", "wait"]\n    humanoid_spin:\n      plugin: "nav2_recoveries/Spin"\n      # Humanoid-specific parameters\n      spin_dist: 1.57  # 90 degrees in radians\n      time_allowance: 10.0\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 10.0  # Lower frequency for stability\n    min_x_velocity_threshold: 0.01\n    min_y_velocity_threshold: 0.01\n    min_theta_velocity_threshold: 0.01\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["HumanoidMppiController"]\n    \n    # Progress checker parameters for humanoid\n    progress_checker:\n      plugin: "nav2_controller::SimpleProgressChecker"\n      required_movement_radius: 0.1  # Smaller for precise movement\n      movement_time_allowance: 30.0  # Longer allowance for complex movement\n      \n    # Goal checker parameters\n    goal_checker:\n      plugin: "nav2_controller::SimpleGoalChecker"\n      xy_goal_tolerance: 0.1  # Tighter tolerance for precise positioning\n      yaw_goal_tolerance: 0.1  # Tighter orientation tolerance\n      stateful: True\n      \n    # Humanoid-specific controller\n    HumanoidMppiController:\n      plugin: "isaac_ros_mppi_controller/HumanoidMppiController"\n      time_steps: 20  # More steps for complex humanoid motion\n      control_freq: 10  # Lower frequency for stability\n      horizon: 2.0  # Longer horizon for better planning\n      Q: [5.0, 3.0, 0.5, 2.0]  # Higher weights for humanoid-specific costs\n      R: [2.0]\n      motion_model: "BipedalWalk"\n      reference_time: 0.5\n      # Humanoid-specific obstacle avoidance\n      aux_reward: ["obstacles", "goal", "ref_path", "balance"]\n      obstacles:\n        plugin: "nav2_mppi_controller::ObstaclesCost"\n        threshold_to_stop_at_obstacle: 0.5  # Humanoid needs more space\n        scaling_dist: 0.8\n        scaling_speed: 0.5\n      goal:\n        plugin: "nav2_mppi_controller::GoalCost"\n      ref_path:\n        plugin: "nav2_mppi_controller::PathCost"\n        traveled_path_topic: "local_plan"\n        max_look_ahead: 1.5\n      balance:\n        plugin: "isaac_ros_mppi_controller::BalanceCost"\n        com_tolerance: 0.05  # Center of mass tolerance in meters\n'})}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-specific-path-planning-algorithms",children:"Humanoid-Specific Path Planning Algorithms"}),"\n",(0,i.jsx)(e.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,i.jsx)(e.p,{children:"Footstep planning is critical for bipedal locomotion:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Example humanoid footstep planning\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom nav_msgs.msg import Path\nfrom visualization_msgs.msg import MarkerArray\nimport numpy as np\n\nclass HumanoidFootstepPlannerNode(Node):\n    def __init__(self):\n        super().__init__('humanoid_footstep_planner')\n        \n        # Subscriptions\n        self.goal_sub = self.create_subscription(\n            PoseStamped,\n            '/goal_pose',\n            self.goal_callback,\n            10\n        )\n        \n        # Publishers\n        self.footstep_pub = self.create_publisher(\n            Path,\n            '/footstep_plan',\n            10\n        )\n        \n        self.visualization_pub = self.create_publisher(\n            MarkerArray,\n            '/footstep_visualization',\n            10\n        )\n        \n        # Humanoid-specific parameters\n        self.step_length = 0.3  # meters\n        self.step_width = 0.2  # meters (distance between feet)\n        self.max_step_turn = 0.5  # radians\n        self.support_polygon = 0.1  # margin for stability\n        \n        self.current_pose = None\n        self.goal_pose = None\n    \n    def goal_callback(self, msg):\n        self.goal_pose = msg.pose\n        if self.current_pose is not None:\n            self.plan_footsteps()\n    \n    def plan_footsteps(self):\n        if self.current_pose is None or self.goal_pose is None:\n            return\n            \n        # Calculate path from current to goal\n        footsteps = self.calculate_footsteps(\n            self.current_pose, \n            self.goal_pose\n        )\n        \n        # Publish footsteps as path\n        self.publish_footsteps(footsteps)\n        \n        # Visualize footsteps\n        self.visualize_footsteps(footsteps)\n    \n    def calculate_footsteps(self, start_pose, goal_pose):\n        footsteps = []\n        \n        # Calculate direction vector to goal\n        dx = goal_pose.position.x - start_pose.position.x\n        dy = goal_pose.position.y - start_pose.position.y\n        distance = np.sqrt(dx**2 + dy**2)\n        \n        # Calculate number of steps needed\n        num_steps = int(distance / self.step_length) + 1\n        \n        # Generate footsteps along the path\n        for i in range(1, num_steps + 1):\n            # Calculate intermediate position\n            step_ratio = i / num_steps\n            step_x = start_pose.position.x + dx * step_ratio\n            step_y = start_pose.position.y + dy * step_ratio\n            \n            # Alternate feet (left/right)\n            if i % 2 == 1:  # Left foot\n                step_y += self.step_width / 2\n            else:  # Right foot\n                step_y -= self.step_width / 2\n                \n            # Create footstep pose\n            footstep = PoseStamped()\n            footstep.header.stamp = self.get_clock().now().to_msg()\n            footstep.header.frame_id = 'map'\n            footstep.pose.position.x = step_x\n            footstep.pose.position.y = step_y\n            footstep.pose.position.z = 0.0  # Ground level\n            footstep.pose.orientation.w = 1.0  # No rotation for simplicity\n            \n            footsteps.append(footstep)\n        \n        return footsteps\n    \n    def publish_footsteps(self, footsteps):\n        path_msg = Path()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = 'map'\n        path_msg.poses = footsteps\n        \n        self.footstep_pub.publish(path_msg)\n    \n    def visualize_footsteps(self, footsteps):\n        marker_array = MarkerArray()\n        \n        for i, footstep in enumerate(footsteps):\n            # Create a marker for each footstep\n            marker = Marker()\n            marker.header = footstep.header\n            marker.ns = \"footsteps\"\n            marker.id = i\n            marker.type = Marker.CYLINDER\n            marker.action = Marker.ADD\n            \n            # Position\n            marker.pose = footstep.pose\n            \n            # Size (representing foot size)\n            marker.scale.x = 0.15  # Foot length\n            marker.scale.y = 0.1   # Foot width\n            marker.scale.z = 0.01  # Height of visualization\n            \n            # Color (alternating for left/right feet)\n            marker.color.a = 0.8\n            if i % 2 == 0:  # Left foot\n                marker.color.r = 1.0\n                marker.color.g = 0.0\n                marker.color.b = 0.0\n            else:  # Right foot\n                marker.color.r = 0.0\n                marker.color.g = 0.0\n                marker.color.b = 1.0\n                \n            marker_array.markers.append(marker)\n        \n        self.visualization_pub.publish(marker_array)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"whole-body-path-planning",children:"Whole-Body Path Planning"}),"\n",(0,i.jsx)(e.p,{children:"For complex humanoid movement, consider the entire body:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Example whole-body path planning\nclass HumanoidWholeBodyPlannerNode(Node):\n    def __init__(self):\n        super().__init__('humanoid_whole_body_planner')\n        \n        # Publishers for full body trajectory\n        self.joint_trajectory_pub = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory',\n            10\n        )\n        \n        # Humanoid kinematic model\n        self.kinematic_model = self.create_kinematic_model()\n        \n    def create_kinematic_model(self):\n        # Define humanoid kinematic chain\n        # This is a simplified model - real implementation would be more complex\n        return {\n            'left_leg': {\n                'hip_pitch': (-1.57, 1.57),  # Joint limits in radians\n                'hip_roll': (-0.5, 0.5),\n                'hip_yaw': (-1.0, 1.0),\n                'knee': (0.0, 2.5),\n                'ankle_pitch': (-0.5, 0.5),\n                'ankle_roll': (-0.3, 0.3)\n            },\n            'right_leg': {\n                'hip_pitch': (-1.57, 1.57),\n                'hip_roll': (-0.5, 0.5),\n                'hip_yaw': (-1.0, 1.0),\n                'knee': (0.0, 2.5),\n                'ankle_pitch': (-0.5, 0.5),\n                'ankle_roll': (-0.3, 0.3)\n            },\n            'torso': {\n                'pitch': (-0.3, 0.3),\n                'roll': (-0.3, 0.3),\n                'yaw': (-1.0, 1.0)\n            }\n        }\n    \n    def plan_whole_body_trajectory(self, start_pose, goal_pose):\n        # Plan a trajectory that considers full body kinematics\n        trajectory = JointTrajectory()\n        trajectory.joint_names = [\n            'left_hip_pitch', 'left_hip_roll', 'left_hip_yaw',\n            'left_knee', 'left_ankle_pitch', 'left_ankle_roll',\n            'right_hip_pitch', 'right_hip_roll', 'right_hip_yaw',\n            'right_knee', 'right_ankle_pitch', 'right_ankle_roll',\n            'torso_pitch', 'torso_roll', 'torso_yaw'\n        ]\n        \n        # Generate trajectory points\n        num_points = 100\n        for i in range(num_points):\n            point = JointTrajectoryPoint()\n            \n            # Calculate joint positions for this point in the trajectory\n            # This would use inverse kinematics and dynamics\n            joint_positions = self.calculate_body_posture(\n                start_pose, goal_pose, i / num_points\n            )\n            \n            point.positions = joint_positions\n            point.time_from_start.sec = int(i * 0.1)  # 100ms per point\n            point.time_from_start.nanosec = int((i * 0.1 - int(i * 0.1)) * 1e9)\n            \n            trajectory.points.append(point)\n        \n        return trajectory\n    \n    def calculate_body_posture(self, start_pose, goal_pose, progress):\n        # Calculate appropriate body posture based on progress\n        # This would involve complex inverse kinematics and balance constraints\n        # For demonstration, return a simplified posture\n        return [0.0] * 15  # 15 joint positions, all at neutral\n"})}),"\n",(0,i.jsx)(e.h2,{id:"gpu-accelerated-path-planning",children:"GPU-Accelerated Path Planning"}),"\n",(0,i.jsx)(e.h3,{id:"isaacs-gpu-accelerated-algorithms",children:"Isaac's GPU-Accelerated Algorithms"}),"\n",(0,i.jsx)(e.p,{children:"Isaac provides GPU acceleration for complex path planning:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Example of GPU-accelerated humanoid path planning\nimport numpy as np\nimport cupy as cp  # Use CuPy for GPU computations\n\nclass IsaacGPUHumanoidPlannerNode(Node):\n    def __init__(self):\n        super().__init__('isaac_gpu_humanoid_planner')\n        \n        # Initialize GPU arrays for planning\n        self.setup_gpu_resources()\n        \n    def setup_gpu_resources(self):\n        # Allocate GPU memory for planning operations\n        # This would include space for:\n        # - Costmap representation\n        # - Path planning data structures\n        # - Collision checking grids\n        self.costmap_gpu = cp.zeros((2000, 2000), dtype=cp.float32)  # 2000x2000 grid\n        self.temp_path_gpu = cp.zeros((1000, 2), dtype=cp.float32)   # Up to 1000 waypoints\n        self.footprint_gpu = cp.zeros((10, 2), dtype=cp.float32)     # 10-point robot footprint\n        \n        # Initialize the humanoid-specific footprint\n        self.initialize_humanoid_footprint()\n    \n    def initialize_humanoid_footprint(self):\n        # Define the humanoid's support polygon on the GPU\n        # This represents the area that must remain stable during movement\n        foot_points = cp.array([\n            [-0.1, -0.05],  # Back left\n            [0.1, -0.05],   # Back right\n            [0.15, 0.0],    # Front right\n            [0.1, 0.05],    # Front right tip\n            [-0.1, 0.05],   # Front left tip\n            [-0.15, 0.0]    # Front left\n        ], dtype=cp.float32)\n        \n        self.footprint_gpu[:len(foot_points)] = foot_points\n    \n    def gpu_path_planning(self, start, goal, costmap_cpu):\n        # Transfer costmap to GPU\n        costmap_gpu = cp.asarray(costmap_cpu, dtype=cp.float32)\n        \n        # Perform GPU-accelerated path planning\n        # This would use Isaac's optimized GPU algorithms\n        path = self.execute_gpu_astar(start, goal, costmap_gpu)\n        \n        # Transfer result back to CPU\n        path_cpu = cp.asnumpy(path)\n        \n        return path_cpu\n    \n    def execute_gpu_astar(self, start, goal, costmap_gpu):\n        # Execute A* algorithm on GPU (conceptual)\n        # In practice, this would use Isaac's optimized GPU implementations\n        start_gpu = cp.array(start, dtype=cp.float32)\n        goal_gpu = cp.array(goal, dtype=cp.float32)\n        \n        # Placeholder for actual GPU path planning algorithm\n        # This would implement A* or another path planning algorithm on GPU\n        path = cp.array([[start[0], start[1]], [goal[0], goal[1]]], dtype=cp.float32)\n        \n        return path\n"})}),"\n",(0,i.jsx)(e.h2,{id:"balance-aware-path-planning",children:"Balance-Aware Path Planning"}),"\n",(0,i.jsx)(e.h3,{id:"center-of-mass-constraints",children:"Center of Mass Constraints"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid path planning must consider balance:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Example of balance-aware path planning\nclass BalanceAwarePlannerNode(Node):\n    def __init__(self):\n        super().__init__('balance_aware_planner')\n        \n        # Parameters for balance constraints\n        self.com_margin = 0.05  # 5cm margin for center of mass\n        self.zmp_limit = 0.1    # 10cm limit for zero moment point\n        self.support_polygon_radius = 0.15  # Support polygon radius\n        \n    def is_path_balanced(self, path, robot_state):\n        # Check if a path maintains balance throughout\n        for i, waypoint in enumerate(path):\n            # Calculate CoM position for this waypoint\n            com_pos = self.calculate_com_position(waypoint, robot_state)\n            \n            # Check if CoM is within support polygon\n            if not self.is_com_stable(com_pos, robot_state):\n                self.get_logger().warn(f\"Path becomes unstable at waypoint {i}\")\n                return False\n        \n        return True\n    \n    def calculate_com_position(self, waypoint, robot_state):\n        # Calculate center of mass position based on robot configuration\n        # This would use forward kinematics\n        # For demonstration, return a simplified calculation\n        return (waypoint.position.x, waypoint.position.y)\n    \n    def is_com_stable(self, com_pos, robot_state):\n        # Check if the center of mass is within the support polygon\n        # The support polygon is defined by the feet positions\n        left_foot_pos = self.get_left_foot_position(robot_state)\n        right_foot_pos = self.get_right_foot_position(robot_state)\n        \n        # Calculate support polygon (simplified as rectangle between feet)\n        min_x = min(left_foot_pos[0], right_foot_pos[0]) - self.support_polygon_radius\n        max_x = max(left_foot_pos[0], right_foot_pos[0]) + self.support_polygon_radius\n        min_y = min(left_foot_pos[1], right_foot_pos[1]) - self.support_polygon_radius\n        max_y = max(left_foot_pos[1], right_foot_pos[1]) + self.support_polygon_radius\n        \n        # Check if CoM is within the support polygon with margin\n        return (min_x + self.com_margin <= com_pos[0] <= max_x - self.com_margin and\n                min_y + self.com_margin <= com_pos[1] <= max_y - self.com_margin)\n    \n    def get_left_foot_position(self, robot_state):\n        # Get left foot position from robot state\n        # This would access the robot's kinematic state\n        return (0.0, 0.1)  # Example position\n    \n    def get_right_foot_position(self, robot_state):\n        # Get right foot position from robot state\n        # This would access the robot's kinematic state\n        return (0.0, -0.1)  # Example position\n"})}),"\n",(0,i.jsx)(e.h2,{id:"terrain-aware-path-planning",children:"Terrain-Aware Path Planning"}),"\n",(0,i.jsx)(e.h3,{id:"handling-different-terrains",children:"Handling Different Terrains"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots need to plan paths that account for terrain characteristics:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Example terrain-aware path planning\nclass TerrainAwarePlannerNode(Node):\n    def __init__(self):\n        super().__init__('terrain_aware_planner')\n        \n        # Terrain classification parameters\n        self.terrain_types = {\n            'flat': {'traversability': 1.0, 'cost_multiplier': 1.0},\n            'uneven': {'traversability': 0.7, 'cost_multiplier': 1.5},\n            'stairs': {'traversability': 0.5, 'cost_multiplier': 2.0},\n            'narrow': {'traversability': 0.8, 'cost_multiplier': 1.2}\n        }\n        \n        # Subscribe to terrain classification\n        self.terrain_sub = self.create_subscription(\n            OccupancyGrid,\n            '/terrain_classification',\n            self.terrain_callback,\n            10\n        )\n        \n        self.terrain_map = None\n    \n    def terrain_callback(self, msg):\n        # Update terrain map with classification data\n        self.terrain_map = np.array(msg.data).reshape(\n            msg.info.height, msg.info.width\n        )\n        self.terrain_resolution = msg.info.resolution\n        self.terrain_origin = (msg.info.origin.position.x, msg.info.origin.position.y)\n    \n    def calculate_terrain_cost(self, position):\n        # Calculate terrain-based cost for a position\n        if self.terrain_map is None:\n            return 1.0  # Default cost if no terrain info available\n            \n        # Convert world position to map coordinates\n        map_x = int((position[0] - self.terrain_origin[0]) / self.terrain_resolution)\n        map_y = int((position[1] - self.terrain_origin[1]) / self.terrain_resolution)\n        \n        # Check bounds\n        if (0 <= map_x < self.terrain_map.shape[1] and \n            0 <= map_y < self.terrain_map.shape[0]):\n            terrain_id = int(self.terrain_map[map_y, map_x])\n            # Map terrain ID to terrain type and get cost multiplier\n            # This is a simplified mapping\n            if terrain_id == 0:\n                terrain_type = 'flat'\n            elif terrain_id == 1:\n                terrain_type = 'uneven'\n            elif terrain_id == 2:\n                terrain_type = 'stairs'\n            else:\n                terrain_type = 'flat'  # Default\n                \n            return self.terrain_types[terrain_type]['cost_multiplier']\n        \n        return 1.0  # Default cost for unknown terrain\n    \n    def plan_terrain_aware_path(self, start, goal):\n        # Plan path considering terrain costs\n        # This would integrate terrain costs into the path planning algorithm\n        path = self.base_path_planning(start, goal)\n        \n        # Adjust path based on terrain\n        adjusted_path = self.adjust_path_for_terrain(path)\n        \n        return adjusted_path\n    \n    def adjust_path_for_terrain(self, path):\n        # Adjust path to avoid difficult terrains where possible\n        # For humanoids, this might mean finding wider paths around obstacles\n        # or choosing flatter routes\n        adjusted_path = []\n        \n        for point in path:\n            # Check terrain cost at this point\n            terrain_cost = self.calculate_terrain_cost((point.position.x, point.position.y))\n            \n            # If terrain is too difficult, try to find alternative\n            if terrain_cost > 1.8:  # Threshold for difficult terrain\n                # Find nearby point with better terrain\n                alternative_point = self.find_better_terrain_nearby(point)\n                adjusted_path.append(alternative_point)\n            else:\n                adjusted_path.append(point)\n        \n        return adjusted_path\n    \n    def find_better_terrain_nearby(self, original_point):\n        # Find a nearby point with better terrain\n        # This would search in a radius around the original point\n        # For demonstration, return the original point\n        return original_point\n"})}),"\n",(0,i.jsx)(e.h2,{id:"integration-with-isaac-sim",children:"Integration with Isaac Sim"}),"\n",(0,i.jsx)(e.h3,{id:"testing-in-simulation",children:"Testing in Simulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# Example of humanoid navigation testing in Isaac Sim\nclass IsaacSimHumanoidNavigationTester:\n    def __init__(self):\n        self.test_scenarios = [\n            {\n                "name": "Flat terrain navigation",\n                "obstacles": [],\n                "terrain": "flat",\n                "difficulty": "easy"\n            },\n            {\n                "name": "Narrow passage",\n                "obstacles": [{"type": "wall", "position": [2, 0, 0], "size": [0.1, 4, 2]}],\n                "terrain": "flat",\n                "difficulty": "medium"\n            },\n            {\n                "name": "Stair navigation",\n                "obstacles": [{"type": "stairs", "position": [3, 0, 0], "size": [2, 1, 0.2]}],\n                "terrain": "stairs",\n                "difficulty": "hard"\n            }\n        ]\n    \n    def setup_test_scenario(self, scenario):\n        # Set up Isaac Sim environment for the test scenario\n        print(f"Setting up scenario: {scenario[\'name\']}")\n        \n        # Create obstacles in the simulation\n        for obstacle in scenario.get("obstacles", []):\n            self.create_obstacle_in_sim(obstacle)\n    \n    def run_navigation_test(self, scenario):\n        # Run navigation test for the scenario\n        print(f"Running navigation test: {scenario[\'name\']}")\n        \n        # Execute navigation and measure performance\n        success = self.execute_navigation_test()\n        metrics = self.collect_performance_metrics()\n        \n        return {\n            "scenario": scenario["name"],\n            "success": success,\n            "metrics": metrics\n        }\n    \n    def execute_navigation_test(self):\n        # Execute the navigation test\n        # This would interface with the ROS navigation stack\n        return True  # Placeholder\n    \n    def collect_performance_metrics(self):\n        # Collect performance metrics for the test\n        return {\n            "path_efficiency": 0.85,\n            "com_stability": 0.95,\n            "computation_time": 0.12\n        }\n    \n    def create_obstacle_in_sim(self, obstacle):\n        # Create an obstacle in Isaac Sim\n        # Implementation would interface with Isaac Sim API\n        pass\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices-for-humanoid-path-planning",children:"Best Practices for Humanoid Path Planning"}),"\n",(0,i.jsx)(e.h3,{id:"1-multi-layer-planning",children:"1. Multi-Layer Planning"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Plan at different levels of abstraction"}),"\n",(0,i.jsx)(e.li,{children:"Global path planning for long-term goals"}),"\n",(0,i.jsx)(e.li,{children:"Local planning for obstacle avoidance"}),"\n",(0,i.jsx)(e.li,{children:"Footstep planning for immediate steps"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"2-balance-integration",children:"2. Balance Integration"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Always consider balance constraints"}),"\n",(0,i.jsx)(e.li,{children:"Plan with center of mass margins"}),"\n",(0,i.jsx)(e.li,{children:"Account for dynamic stability during movement"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"3-terrain-adaptation",children:"3. Terrain Adaptation"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Classify terrain types in the environment"}),"\n",(0,i.jsx)(e.li,{children:"Adjust planning parameters based on terrain"}),"\n",(0,i.jsx)(e.li,{children:"Plan different gaits for different terrains"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"4-performance-optimization",children:"4. Performance Optimization"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use GPU acceleration for complex computations"}),"\n",(0,i.jsx)(e.li,{children:"Implement efficient data structures"}),"\n",(0,i.jsx)(e.li,{children:"Balance planning quality with computation time"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"5-validation-and-testing",children:"5. Validation and Testing"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Test extensively in simulation"}),"\n",(0,i.jsx)(e.li,{children:"Validate on physical robots gradually"}),"\n",(0,i.jsx)(e.li,{children:"Monitor balance and stability metrics"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Path planning for bipedal humanoid robots requires specialized approaches that consider the unique challenges of legged locomotion, balance, and complex kinematics. NVIDIA Isaac provides the tools and GPU acceleration needed to implement these sophisticated planning algorithms effectively."})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>s});var a=t(6540);const i={},o=a.createContext(i);function r(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);