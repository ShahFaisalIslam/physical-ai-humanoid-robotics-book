"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[4408],{8453(e,n,i){i.d(n,{R:()=>c,x:()=>s});var t=i(6540);const l={},o=t.createContext(l);function c(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),t.createElement(o.Provider,{value:n},e.children)}},9945(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"module-1-ros-fundamentals/lifecycle-execution","title":"ROS 2 Lifecycle and Execution Model","description":"Understanding the ROS 2 lifecycle and execution model is crucial for developing robust robotic applications. This section explains how ROS 2 nodes are managed, executed, and how they interact with the system.","source":"@site/docs/module-1-ros-fundamentals/lifecycle-execution.md","sourceDirName":"module-1-ros-fundamentals","slug":"/module-1-ros-fundamentals/lifecycle-execution","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1-ros-fundamentals/lifecycle-execution","draft":false,"unlisted":false,"editUrl":"https://github.com/your-organization/physical-ai-humanoid-robotics-book/edit/main/book/docs/module-1-ros-fundamentals/lifecycle-execution.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7}}');var l=i(4848),o=i(8453);const c={sidebar_position:7},s="ROS 2 Lifecycle and Execution Model",r={},a=[{value:"ROS 2 Execution Model",id:"ros-2-execution-model",level:2},{value:"Node Initialization and Execution",id:"node-initialization-and-execution",level:3},{value:"Execution Contexts",id:"execution-contexts",level:2},{value:"Single-threaded Executor",id:"single-threaded-executor",level:3},{value:"Multi-threaded Executor",id:"multi-threaded-executor",level:3},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:2},{value:"Lifecycle States",id:"lifecycle-states",level:3},{value:"State Transitions",id:"state-transitions",level:3},{value:"Lifecycle Node Example",id:"lifecycle-node-example",level:3},{value:"Callback Groups",id:"callback-groups",level:2},{value:"Spin Variants",id:"spin-variants",level:2},{value:"Standard Spin",id:"standard-spin",level:3},{value:"Spin Once",id:"spin-once",level:3},{value:"Spin Until Future Complete",id:"spin-until-future-complete",level:3},{value:"Threading Model",id:"threading-model",level:2},{value:"Quality of Service (QoS) and Execution",id:"quality-of-service-qos-and-execution",level:2},{value:"Best Practices for Execution",id:"best-practices-for-execution",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"ros-2-lifecycle-and-execution-model",children:"ROS 2 Lifecycle and Execution Model"})}),"\n",(0,l.jsx)(n.p,{children:"Understanding the ROS 2 lifecycle and execution model is crucial for developing robust robotic applications. This section explains how ROS 2 nodes are managed, executed, and how they interact with the system."}),"\n",(0,l.jsx)(n.h2,{id:"ros-2-execution-model",children:"ROS 2 Execution Model"}),"\n",(0,l.jsx)(n.p,{children:"ROS 2 uses a distributed execution model where nodes can run on different processes, devices, or even networks. Unlike the original ROS, ROS 2 does not require a central master node, making it more robust and suitable for production environments."}),"\n",(0,l.jsx)(n.h3,{id:"node-initialization-and-execution",children:"Node Initialization and Execution"}),"\n",(0,l.jsx)(n.p,{children:"The typical lifecycle of a ROS 2 node involves several phases:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Initialization"}),": The node is created and configured"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Activation"}),": The node becomes active and can participate in communication"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Execution"}),": The node runs and processes messages, services, etc."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Shutdown"}),": The node is properly cleaned up"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\ndef main(args=None):\n    # 1. Initialize ROS communications\n    rclpy.init(args=args)\n    \n    # 2. Create node instance\n    node = MyNode()\n    \n    # 3. Execute node (blocking call)\n    rclpy.spin(node)\n    \n    # 4. Clean up\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,l.jsx)(n.h2,{id:"execution-contexts",children:"Execution Contexts"}),"\n",(0,l.jsx)(n.p,{children:"ROS 2 provides different execution contexts to handle callbacks:"}),"\n",(0,l.jsx)(n.h3,{id:"single-threaded-executor",children:"Single-threaded Executor"}),"\n",(0,l.jsx)(n.p,{children:"The default executor that processes callbacks sequentially in a single thread:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from rclpy.executors import SingleThreadedExecutor\n\nexecutor = SingleThreadedExecutor()\nexecutor.add_node(node)\nexecutor.spin()\nexecutor.shutdown()\n"})}),"\n",(0,l.jsx)(n.h3,{id:"multi-threaded-executor",children:"Multi-threaded Executor"}),"\n",(0,l.jsx)(n.p,{children:"Processes callbacks in multiple threads, allowing for concurrent execution:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from rclpy.executors import MultiThreadedExecutor\n\nexecutor = MultiThreadedExecutor(num_threads=4)\nexecutor.add_node(node)\nexecutor.spin()\nexecutor.shutdown()\n"})}),"\n",(0,l.jsx)(n.h2,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,l.jsx)(n.p,{children:"For more complex systems requiring explicit state management, ROS 2 provides LifecycleNodes:"}),"\n",(0,l.jsx)(n.h3,{id:"lifecycle-states",children:"Lifecycle States"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Unconfigured"}),": Node is created but not configured"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Inactive"}),": Node is configured but not active"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Active"}),": Node is running and participating in communication"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Finalized"}),": Node is shut down"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"state-transitions",children:"State Transitions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Unconfigured \u2192 Inactive (configure transition)"}),"\n",(0,l.jsx)(n.li,{children:"Inactive \u2192 Active (activate transition)"}),"\n",(0,l.jsx)(n.li,{children:"Active \u2192 Inactive (deactivate transition)"}),"\n",(0,l.jsx)(n.li,{children:"Active \u2192 Finalized (cleanup transition)"}),"\n",(0,l.jsx)(n.li,{children:"Inactive \u2192 Finalized (cleanup transition)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"lifecycle-node-example",children:"Lifecycle Node Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from rclpy.lifecycle import LifecycleNode, LifecycleState\nfrom rclpy.lifecycle import TransitionCallbackReturn\n\nclass MyLifecycleNode(LifecycleNode):\n    def __init__(self):\n        super().__init__('my_lifecycle_node')\n        \n    def on_configure(self, state):\n        self.get_logger().info(f'Configuring from state: {state}')\n        # Initialize resources here\n        return TransitionCallbackReturn.SUCCESS\n        \n    def on_activate(self, state):\n        self.get_logger().info(f'Activating from state: {state}')\n        # Activate components\n        return TransitionCallbackReturn.SUCCESS\n        \n    def on_deactivate(self, state):\n        self.get_logger().info(f'Deactivating from state: {state}')\n        # Deactivate components\n        return TransitionCallbackReturn.SUCCESS\n        \n    def on_cleanup(self, state):\n        self.get_logger().info(f'Cleaning up from state: {state}')\n        # Clean up resources\n        return TransitionCallbackReturn.SUCCESS\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MyLifecycleNode()\n    \n    # Initially in unconfigured state\n    node.trigger_configure()  # Transition to inactive\n    node.trigger_activate()   # Transition to active\n    # ... do work ...\n    node.trigger_deactivate() # Transition back to inactive\n    node.trigger_cleanup()    # Transition back to unconfigured\n    node.trigger_shutdown()   # Finalize the node\n    \n    rclpy.shutdown()\n"})}),"\n",(0,l.jsx)(n.h2,{id:"callback-groups",children:"Callback Groups"}),"\n",(0,l.jsx)(n.p,{children:"Callback groups allow you to control which callbacks are executed together:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n\n# Mutually exclusive: only one callback in the group runs at a time\ncb_group = MutuallyExclusiveCallbackGroup()\n\n# Reentrant: multiple callbacks in the group can run simultaneously\nreentrant_group = ReentrantCallbackGroup()\n\n# Use in creating subscriptions/services\nsub = self.create_subscription(\n    String,\n    'topic',\n    callback,\n    10,\n    callback_group=cb_group\n)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"spin-variants",children:"Spin Variants"}),"\n",(0,l.jsx)(n.p,{children:"ROS 2 provides different spin methods for different use cases:"}),"\n",(0,l.jsx)(n.h3,{id:"standard-spin",children:"Standard Spin"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"rclpy.spin(node)  # Blocks until node is shut down\n"})}),"\n",(0,l.jsx)(n.h3,{id:"spin-once",children:"Spin Once"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"rclpy.spin_once(node, timeout_sec=1.0)  # Process available callbacks once\n"})}),"\n",(0,l.jsx)(n.h3,{id:"spin-until-future-complete",children:"Spin Until Future Complete"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"future = client.call_async(request)\nrclpy.spin_until_future_complete(node, future)  # Wait for service call\n"})}),"\n",(0,l.jsx)(n.h2,{id:"threading-model",children:"Threading Model"}),"\n",(0,l.jsx)(n.p,{children:"ROS 2 uses a flexible threading model:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Node-local threading"}),": Each node can have its own executor"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Callback-based"}),": Callbacks are executed by executors"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Waitable objects"}),": Timers, subscriptions, services, etc. are all waitable"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Concurrent processing"}),": Multiple executors can run concurrently"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"quality-of-service-qos-and-execution",children:"Quality of Service (QoS) and Execution"}),"\n",(0,l.jsx)(n.p,{children:"QoS settings affect how messages are handled during execution:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n# Reliable communication with last 10 messages\nqos_profile = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=HistoryPolicy.KEEP_LAST\n)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"best-practices-for-execution",children:"Best Practices for Execution"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Choose the right executor"}),": Use single-threaded for simple nodes, multi-threaded for complex ones"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Use lifecycle nodes"}),": For complex systems requiring explicit state management"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Handle shutdown gracefully"}),": Always clean up resources in node destruction"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Use appropriate QoS settings"}),": Match communication requirements to application needs"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Avoid blocking in callbacks"}),": Keep callbacks lightweight to maintain responsiveness"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Use callback groups"}),": To control execution order and concurrency"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Understanding the ROS 2 lifecycle and execution model is essential for creating robust and efficient robotic applications that can handle complex state transitions and concurrent operations."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);