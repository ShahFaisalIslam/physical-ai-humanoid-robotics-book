"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[4292],{7252(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-2-digital-twin/gazebo-plugins","title":"Gazebo Plugin Development","description":"Gazebo plugins extend the simulator\'s functionality, enabling custom behaviors, sensors, and integration with external systems like ROS. This section covers the fundamentals of Gazebo plugin development with practical examples.","source":"@site/docs/module-2-digital-twin/gazebo-plugins.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/gazebo-plugins","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/gazebo-plugins","draft":false,"unlisted":false,"editUrl":"https://github.com/your-organization/physical-ai-humanoid-robotics-book/edit/main/book/docs/module-2-digital-twin/gazebo-plugins.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11}}');var t=i(4848),l=i(8453);const o={sidebar_position:11},r="Gazebo Plugin Development",a={},d=[{value:"Plugin Architecture",id:"plugin-architecture",level:2},{value:"Basic Plugin Structure",id:"basic-plugin-structure",level:2},{value:"World Plugin Example",id:"world-plugin-example",level:3},{value:"Model Plugin Example",id:"model-plugin-example",level:3},{value:"ROS Integration Plugins",id:"ros-integration-plugins",level:2},{value:"ROS Publisher Plugin",id:"ros-publisher-plugin",level:3},{value:"ROS Subscriber Plugin",id:"ros-subscriber-plugin",level:3},{value:"Sensor Plugin Example",id:"sensor-plugin-example",level:2},{value:"Plugin Configuration in SDF",id:"plugin-configuration-in-sdf",level:2},{value:"Model with Plugin",id:"model-with-plugin",level:3},{value:"World with Plugin",id:"world-with-plugin",level:3},{value:"Advanced Plugin Concepts",id:"advanced-plugin-concepts",level:2},{value:"Using Custom Messages",id:"using-custom-messages",level:3},{value:"Parameter Handling",id:"parameter-handling",level:3},{value:"Error Handling and Logging",id:"error-handling-and-logging",level:3},{value:"Build Configuration",id:"build-configuration",level:2},{value:"CMakeLists.txt for Plugin",id:"cmakeliststxt-for-plugin",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Resource Management",id:"1-resource-management",level:3},{value:"2. Thread Safety",id:"2-thread-safety",level:3},{value:"3. Performance",id:"3-performance",level:3},{value:"4. Error Handling",id:"4-error-handling",level:3},{value:"5. Testing",id:"5-testing",level:3}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"gazebo-plugin-development",children:"Gazebo Plugin Development"})}),"\n",(0,t.jsx)(e.p,{children:"Gazebo plugins extend the simulator's functionality, enabling custom behaviors, sensors, and integration with external systems like ROS. This section covers the fundamentals of Gazebo plugin development with practical examples."}),"\n",(0,t.jsx)(e.h2,{id:"plugin-architecture",children:"Plugin Architecture"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo supports several types of plugins:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"World plugins"}),": Affect the entire simulation world"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model plugins"}),": Attach to specific models"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor plugins"}),": Extend sensor capabilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"System plugins"}),": Core system extensions"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"basic-plugin-structure",children:"Basic Plugin Structure"}),"\n",(0,t.jsx)(e.h3,{id:"world-plugin-example",children:"World Plugin Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n\nnamespace gazebo\n{\n  class CustomWorldPlugin : public WorldPlugin\n  {\n    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)\n    {\n      // Store the world pointer for later use\n      this->world = _world;\n      \n      // Read custom parameters from SDF\n      if (_sdf->HasElement("custom_param"))\n        this->customParam = _sdf->Get<double>("custom_param");\n      else\n        this->customParam = 1.0;  // Default value\n      \n      // Connect to the world update event\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          std::bind(&CustomWorldPlugin::OnUpdate, this));\n      \n      gzmsg << "Custom world plugin loaded with param: " << this->customParam << std::endl;\n    }\n\n    public: void OnUpdate()\n    {\n      // Custom update logic here\n      // This runs every simulation iteration\n      \n      // Example: Apply a force to all models\n      for (auto model : this->world->Models())\n      {\n        // Apply a small upward force to all models\n        math::Vector3 force(0, 0, 0.1);\n        model->GetLink()->AddForce(force);\n      }\n    }\n\n    private: physics::WorldPtr world;\n    private: double customParam;\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_WORLD_PLUGIN(CustomWorldPlugin)\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"model-plugin-example",children:"Model Plugin Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n\nnamespace gazebo\n{\n  class CustomModelPlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n    {\n      // Store the model pointer\n      this->model = _model;\n      \n      // Get a pointer to the first joint (for demonstration)\n      this->joint = _model->GetJoint("joint_name");\n      \n      if (!this->joint)\n      {\n        gzerr << "No joint named \'joint_name\' found in model \'" \n              << _model->GetName() << "\'. Plugin not loaded.\\n";\n        return;\n      }\n      \n      // Listen to the update event to control the joint\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          std::bind(&CustomModelPlugin::OnUpdate, this));\n    }\n\n    public: void OnUpdate()\n    {\n      // Control the joint position\n      if (this->joint)\n      {\n        // Example: Set joint to oscillate\n        double time = this->model->GetWorld()->GetSimTime().Double();\n        double targetPos = 0.5 * sin(time * 2.0); // Oscillate at 2 rad/s\n        this->joint->SetPosition(0, targetPos);\n      }\n    }\n\n    private: physics::ModelPtr model;\n    private: physics::JointPtr joint;\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_MODEL_PLUGIN(CustomModelPlugin)\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"ros-integration-plugins",children:"ROS Integration Plugins"}),"\n",(0,t.jsx)(e.h3,{id:"ros-publisher-plugin",children:"ROS Publisher Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <ros/ros.h>\n#include <std_msgs/Float64.h>\n\nnamespace gazebo\n{\n  class ROSPublisherPlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n    {\n      // Initialize ROS if not already initialized\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = NULL;\n        ros::init(argc, argv, "gazebo_ros_publisher_plugin",\n                  ros::init_options::NoSigintHandler);\n      }\n      \n      // Create ROS node handle\n      this->rosNode.reset(new ros::NodeHandle("gazebo_ros_publisher_plugin"));\n      \n      // Create publisher\n      this->pub = this->rosNode->advertise<std_msgs::Float64>("/model_position", 1);\n      \n      // Store model pointer\n      this->model = _model;\n      \n      // Connect to update event\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          std::bind(&ROSPublisherPlugin::OnUpdate, this));\n    }\n\n    public: void OnUpdate()\n    {\n      // Get model position\n      math::Pose pose = this->model->GetWorldPose();\n      double zPos = pose.pos.z;\n      \n      // Publish to ROS\n      std_msgs::Float64 msg;\n      msg.data = zPos;\n      \n      this->pub.publish(msg);\n    }\n\n    private: physics::ModelPtr model;\n    private: ros::Publisher pub;\n    private: std::unique_ptr<ros::NodeHandle> rosNode;\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  GZ_REGISTER_MODEL_PLUGIN(ROSPublisherPlugin)\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"ros-subscriber-plugin",children:"ROS Subscriber Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <ros/ros.h>\n#include <std_msgs/Float64.h>\n\nnamespace gazebo\n{\n  class ROSSubscriberPlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n    {\n      // Initialize ROS\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = NULL;\n        ros::init(argc, argv, "gazebo_ros_subscriber_plugin",\n                  ros::init_options::NoSigintHandler);\n      }\n      \n      // Create ROS node handle\n      this->rosNode.reset(new ros::NodeHandle("gazebo_ros_subscriber_plugin"));\n      \n      // Create subscriber\n      this->sub = this->rosNode->subscribe("/model_force", 1,\n          &ROSSubscriberPlugin::OnRosMsg, this);\n      \n      // Store model pointer\n      this->model = _model;\n    }\n\n    private: void OnRosMsg(const std_msgs::Float64ConstPtr &_msg)\n    {\n      // Apply force to model based on ROS message\n      math::Vector3 force(0, 0, _msg->data);\n      this->model->GetLink()->AddForce(force);\n    }\n\n    private: physics::ModelPtr model;\n    private: ros::Subscriber sub;\n    private: std::unique_ptr<ros::NodeHandle> rosNode;\n  };\n\n  GZ_REGISTER_MODEL_PLUGIN(ROSSubscriberPlugin)\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"sensor-plugin-example",children:"Sensor Plugin Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/sensors/sensors.hh>\n#include <gazebo/common/common.hh>\n#include <ros/ros.h>\n#include <sensor_msgs/MagneticField.h>\n\nnamespace gazebo\n{\n  class CustomMagnetometerPlugin : public SensorPlugin\n  {\n    public: virtual void Load(sensors::SensorPtr _sensor, sdf::ElementPtr _sdf)\n    {\n      // Get the magnetometer sensor\n      this->parentSensor = std::dynamic_pointer_cast<sensors::MagnetometerSensor>(_sensor);\n      \n      if (!this->parentSensor)\n      {\n        gzerr << "CustomMagnetometerPlugin requires a MagnetometerSensor.\\n";\n        return;\n      }\n      \n      // Initialize ROS\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = NULL;\n        ros::init(argc, argv, "gazebo_magnetometer_plugin",\n                  ros::init_options::NoSigintHandler);\n      }\n      \n      // Create ROS node and publisher\n      this->rosNode.reset(new ros::NodeHandle("gazebo_magnetometer_plugin"));\n      this->pub = this->rosNode->advertise<sensor_msgs::MagneticField>("/magnetic_field", 1);\n      \n      // Connect to sensor update event\n      this->updateConnection = this->parentSensor->ConnectUpdated(\n          std::bind(&CustomMagnetometerPlugin::OnUpdate, this));\n      \n      // Make sure the parent sensor is active\n      this->parentSensor->SetActive(true);\n    }\n\n    public: void OnUpdate()\n    {\n      // Get magnetic field data from sensor\n      ignition::math::Vector3d field = this->parentSensor->MagneticField();\n\n      // Create and publish ROS message\n      sensor_msgs::MagneticField msg;\n      msg.header.stamp = ros::Time::now();\n      msg.header.frame_id = this->parentSensor->FrameId();\n      \n      msg.magnetic_field.x = field.X();\n      msg.magnetic_field.y = field.Y();\n      msg.magnetic_field.z = field.Z();\n      \n      // Add some noise to simulate real sensor\n      static double noise_level = 1e-6;  // 1 microTesla\n      msg.magnetic_field.x += (static_cast<double>(rand()) / RAND_MAX - 0.5) * noise_level;\n      msg.magnetic_field.y += (static_cast<double>(rand()) / RAND_MAX - 0.5) * noise_level;\n      msg.magnetic_field.z += (static_cast<double>(rand()) / RAND_MAX - 0.5) * noise_level;\n      \n      this->pub.publish(msg);\n    }\n\n    private: sensors::MagnetometerSensorPtr parentSensor;\n    private: ros::Publisher pub;\n    private: std::unique_ptr<ros::NodeHandle> rosNode;\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  GZ_REGISTER_SENSOR_PLUGIN(CustomMagnetometerPlugin)\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"plugin-configuration-in-sdf",children:"Plugin Configuration in SDF"}),"\n",(0,t.jsx)(e.h3,{id:"model-with-plugin",children:"Model with Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<model name="custom_robot">\n  \x3c!-- Links and joints --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass>1.0</mass>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n    <visual name="visual">\n      <geometry>\n        <box size="1 1 1"/>\n      </geometry>\n    </visual>\n    <collision name="collision">\n      <geometry>\n        <box size="1 1 1"/>\n      </geometry>\n    </collision>\n  </link>\n  \n  \x3c!-- Attach plugin to model --\x3e\n  <plugin name="custom_model_plugin" filename="libCustomModelPlugin.so">\n    <param_name>param_value</param_name>\n  </plugin>\n</model>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"world-with-plugin",children:"World with Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="custom_world">\n    \x3c!-- Include standard models --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    <include>\n      <uri>model://sun</uri>\n    </include>\n    \n    \x3c!-- Attach world plugin --\x3e\n    <plugin name="custom_world_plugin" filename="libCustomWorldPlugin.so">\n      <custom_param>2.5</custom_param>\n    </plugin>\n    \n    \x3c!-- Models go here --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-plugin-concepts",children:"Advanced Plugin Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"using-custom-messages",children:"Using Custom Messages"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// In your plugin\n#include "custom_msgs/CustomMessage.h"  // Your custom message\n\n// Publisher for custom message\nthis->customPub = this->rosNode->advertise<custom_msgs::CustomMessage>("/custom_topic", 1);\n\n// In your update function\ncustom_msgs::CustomMessage msg;\nmsg.field1 = value1;\nmsg.field2 = value2;\nthis->customPub.publish(msg);\n'})}),"\n",(0,t.jsx)(e.h3,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n{\n  // Required parameter with default\n  this->topicName = _sdf->Get<std::string>("topic_name", "default_topic").first;\n  \n  // Optional parameter with validation\n  if (_sdf->HasElement("update_rate"))\n  {\n    double rate = _sdf->Get<double>("update_rate");\n    if (rate > 0 && rate <= 1000)  // Validate range\n      this->updateRate = rate;\n    else\n      gzerr << "Invalid update rate: " << rate << std::endl;\n  }\n  else\n  {\n    this->updateRate = 100;  // Default 100 Hz\n  }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"error-handling-and-logging",children:"Error Handling and Logging"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n{\n  // Check for required elements\n  if (!_sdf->HasElement("required_param"))\n  {\n    gzerr << "Missing required parameter \'required_param\'\\n";\n    return;\n  }\n  \n  // Validate model structure\n  if (_model->GetJointCount() == 0)\n  {\n    gzerr << "Model has no joints, plugin requires joints\\n";\n    return;\n  }\n  \n  // Log successful initialization\n  gzmsg << "Plugin successfully loaded for model: " << _model->GetName() << std::endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"build-configuration",children:"Build Configuration"}),"\n",(0,t.jsx)(e.h3,{id:"cmakeliststxt-for-plugin",children:"CMakeLists.txt for Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.5)\nproject(custom_gazebo_plugins)\n\n# Find packages\nfind_package(gazebo REQUIRED)\nfind_package(catkin REQUIRED COMPONENTS\n  roscpp\n  std_msgs\n  sensor_msgs\n)\n\n# Set C++ standard\nset(CMAKE_CXX_STANDARD 14)\n\n# Include directories\ninclude_directories(\n  ${catkin_INCLUDE_DIRS}\n  ${GAZEBO_INCLUDE_DIRS}\n)\n\n# Link directories\nlink_directories(\n  ${GAZEBO_LIBRARY_DIRS}\n)\n\n# Add plugin library\nadd_library(CustomModelPlugin SHARED\n  src/custom_model_plugin.cpp\n)\n\n# Link libraries\ntarget_link_libraries(CustomModelPlugin\n  ${GAZEBO_LIBRARIES}\n  ${catkin_LIBRARIES}\n)\n\n# Install plugin\ninstall(TARGETS CustomModelPlugin\n  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}\n)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(e.h3,{id:"1-resource-management",children:"1. Resource Management"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Always clean up connections and resources"}),"\n",(0,t.jsx)(e.li,{children:"Use smart pointers when possible"}),"\n",(0,t.jsx)(e.li,{children:"Avoid memory leaks in long-running simulations"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-thread-safety",children:"2. Thread Safety"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Gazebo plugins typically run in the main simulation thread"}),"\n",(0,t.jsx)(e.li,{children:"Be careful with ROS callbacks that might run in different threads"}),"\n",(0,t.jsx)(e.li,{children:"Use mutexes when sharing data between threads"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-performance",children:"3. Performance"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Keep update functions efficient"}),"\n",(0,t.jsx)(e.li,{children:"Avoid heavy computations in the main simulation loop"}),"\n",(0,t.jsx)(e.li,{children:"Use appropriate update rates"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"4-error-handling",children:"4. Error Handling"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Validate inputs and parameters"}),"\n",(0,t.jsx)(e.li,{children:"Provide meaningful error messages"}),"\n",(0,t.jsx)(e.li,{children:"Fail gracefully when possible"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"5-testing",children:"5. Testing"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test plugins with various simulation scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Validate parameter handling"}),"\n",(0,t.jsx)(e.li,{children:"Check behavior at simulation boundaries (start, stop, reset)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Gazebo plugins provide powerful extensibility for simulation environments. By following these examples and best practices, you can create custom behaviors, sensors, and integrations that enhance your robotic simulation capabilities."})]})}function c(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>r});var s=i(6540);const t={},l=s.createContext(t);function o(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);